% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{Orca Documentation}
\date{November 17, 2014}
\release{1.0.0}
\author{Li, Wang}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


Contents:


\chapter{Introduction}
\label{intro:introduction}\label{intro:welcome-to-orca-s-documentation}\label{intro::doc}
Orca is a Python library specifically designed for backtesting \textbf{statistical arbitrage} strategies(\emph{``alpha''} henceforth) on China A-Shares market.

This library is integrated with a delibrately structured \textbf{MongoDB} as its data source. It depends heavily on the high-performance Python library \href{http://pandas.pydata.org/}{Pandas}, thus it is recommended to get familiar with its basic data structures(Series, DataFrame, Panel).

To experiment with Orca, it is advised that one creates a virtual Python environment with \textbf{virtualenv}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{}virtualenv /your/local/directory
\end{Verbatim}

and install the following dependency libraries properly:
\begin{itemize}
\item {} 
\href{http://pandas.pydata.org/}{Pandas}

\item {} 
\href{http://api.mongodb.org/python/current/}{PyMongo}

\item {} 
\href{http://www.pytables.org/moin/}{PyTables}

\item {} 
\href{https://github.com/mrjbq7/ta-lib}{TA-Lib}

\end{itemize}

Orca has 8 main components:
\begin{itemize}
\item {} 
MongoDB interface

\item {} 
Data cache

\item {} 
Universes

\item {} 
Alphas

\item {} 
Performance

\item {} 
Utilities

\item {} 
Updaters

\item {} 
Alpha DB interface

\end{itemize}

For backtesting purpose, one only have to focus on the first 6 components which are explained in detail in this documentation.


\chapter{Tutorial}
\label{tutorial::doc}\label{tutorial:tutorial}

\section{Play with data}
\label{tutorial:play-with-data}
To fetch data from the underlying MongoDB, the first thing is to find out the fetcher class associated with this data. (These associations should be detailed in a Wiki page.) For example::

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{orca.mongo} \PYG{k+kn}{import} \PYG{n}{QuoteFetcher}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{fetcher} \PYG{o}{=} \PYG{n}{QuoteFetcher}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{fetcher}\PYG{o}{.}\PYG{n}{dnames}
\PYG{g+go}{[\PYGZsq{}open\PYGZsq{}, \PYGZsq{}high\PYGZsq{}, \PYGZsq{}low\PYGZsq{}, \PYGZsq{}close\PYGZsq{}, \PYGZsq{}prevclose\PYGZsq{}, \PYGZsq{}volume\PYGZsq{}, \PYGZsq{}amount\PYGZsq{}, \PYGZsq{}returns\PYGZsq{}]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{fetcher}\PYG{o}{.}\PYG{n}{fetch}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{close}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{20140101}\PYG{p}{,} \PYG{l+m+mi}{20140131}\PYG{p}{)}
\end{Verbatim}

Each fetcher class provides 4 methods tailored for slightly different situations:


\begin{fulllineitems}
\pysiglinewithargsret{\bfcode{fetch}}{\emph{self}, \emph{dname}, \emph{startdate}, \emph{enddate=None}, \emph{backdays=0}}{}
This is most used when one wants to fetch data between two dates(i.e. \code{startdate}, \code{enddate}), both included. When \code{enddate} is None, it defaults to the maximal date available in the MongoDB. \code{backdays} is useful in fetching data with enough history for simulation.
For example, if the simulation starts at 20090101 and on each day, the alpha takes the last 20 days' closing price as input, then one can just set \code{startdate=20090101} and \code{backdays=20}, the fetched closing price will contain data earlier than the first simulation date.

\end{fulllineitems}



\begin{fulllineitems}
\pysiglinewithargsret{\bfcode{fetch\_window}}{\emph{self}, \emph{dname}, \emph{window}}{}
This is most used when one happens to have a consecutive list of trading dates(i.e. \code{window}). It is the actual workhorse behind the scene, of which the other 3 methods are wrappers.

\end{fulllineitems}



\begin{fulllineitems}
\pysiglinewithargsret{\bfcode{fetch\_history}}{\emph{self}, \emph{dname}, \emph{date}, \emph{backdays}}{}
This is intended to be a convenient data fetching method used in production alphas. With \code{delay} properly set in the fetcher instance, this method returns data up to \code{date} with a length of \code{backdays}, i.e. history data with respect to \code{date}, hence the name.

\end{fulllineitems}



\begin{fulllineitems}
\pysiglinewithargsret{\bfcode{fetch\_daily}}{\emph{self}, \emph{dname}, \emph{date}, \emph{offset=0}}{}
This is also intended to be a convenient data fetching method used in production alphas. \code{offset} is usually a positive integer, meaning the returned data is \code{offset}-days ago with respect to \code{date}.

\end{fulllineitems}


A fetcher instance has other attributes that also affect returned data in these fetching methods:
\index{delay}

\begin{fulllineitems}
\phantomsection\label{tutorial:delay}\pysigline{\bfcode{delay}}
This integer affects method \code{fetch\_history()}. Usually it is a non-negative integer and measures the distance between the most recent history data date and \code{date} in the method; in particular, when \code{delay} is 1, the history data does not contain data from \code{date} (if \code{date} itself is a trading day).
One is highly recommended to set this attribute \textbf{explicitly} in the intialization. Though it is always possible to override this attribute by supplying a keyword argument like::

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{quote}\PYG{o}{.}\PYG{n}{fetch\PYGZus{}history}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{close}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{20140111}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{delay}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\bfcode{datetime\_index,~reindex}}
These boolean attributes affects the returned data formats(i.e. index/columns for Series/DataFrame). When \code{datetime} is True, date index will be transformed into DatetimeIndex. When \code{reindex} is True, columns will be reindexed to use a common list of stocks ids. The former is useful in data resampling while the latter is useful to aligh different DataFrames.

\end{fulllineitems}



\section{Build cache}
\label{tutorial:build-cache}
For a research topic, datas employed is usually a very tiny portion of those stored in MongoDB. To reduce database pressure and save time, one is advised to build a cache to save fetched datas. For example::

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{orca.data} \PYG{k+kn}{import} \PYG{n}{CSVSaver}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{saver} \PYG{o}{=} \PYG{n}{CSVSaver}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{./.cache}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{saver}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{close.csv}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{close}
\end{Verbatim}

Later on, the saved data can be read from the cache::

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{orca.data} \PYG{k+kn}{import} \PYG{n}{CSVLoader}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{loader} \PYG{o}{=} \PYG{n}{CSVLoader}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{./cache}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{postfix}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{.csv}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{loaded\PYGZus{}close} \PYG{o}{=} \PYG{n}{loader}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{close}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{orca.utils.testing} \PYG{k+kn}{import} \PYG{n}{frames\PYGZus{}equal}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{frames\PYGZus{}equal}\PYG{p}{(}\PYG{n}{close}\PYG{p}{,} \PYG{n}{loaded\PYGZus{}close}\PYG{p}{)}
\PYG{g+go}{False}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{loader} \PYG{o}{=} \PYG{n}{CSVLoader}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{./cache}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{postfix}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{.csv}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{loader}\PYG{o}{.}\PYG{n}{configure}\PYG{p}{(}\PYG{n}{parse\PYGZus{}date}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{loaded\PYGZus{}close} \PYG{o}{=} \PYG{n}{loader}\PYG{p}{[}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{close}\PYG{l+s}{\PYGZsq{}}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{frames\PYGZus{}equal}\PYG{p}{(}\PYG{n}{close}\PYG{p}{,} \PYG{n}{loaded\PYGZus{}close}\PYG{p}{)}
\PYG{g+go}{True}
\end{Verbatim}

For performance consideration, one is advised to use HDF5 format to save data if this does not bring much anxiety.


\section{Write alphas}
\label{tutorial:write-alphas}
After datas are ready, either fetched from MongoDB or loaded from a temporary cache, one can now write alphas. A dummy example::

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{orca.alpha} \PYG{k+kn}{import} \PYG{n}{BacktestingAlpha}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{class} \PYG{n+nc}{MyAlpha}\PYG{p}{(}\PYG{n}{BacktestingAlpha}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{def} \PYG{n+nf}{generate}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{date}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{alphas}\PYG{p}{[}\PYG{n}{date}\PYG{p}{]} \PYG{o}{=} \PYG{n}{close}\PYG{o}{.}\PYG{n}{ix}\PYG{p}{[}\PYG{n}{date}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{alpha} \PYG{o}{=} \PYG{n}{MyAlpha}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{alpha}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{startdate}\PYG{o}{=}\PYG{l+m+mi}{20140101}\PYG{p}{,} \PYG{n}{enddate}\PYG{o}{=}\PYG{l+m+mi}{20140131}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{alpha}\PYG{o}{.}\PYG{n}{get\PYGZus{}alphas}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

The method \code{get\_alphas} will \textbf{always} return a DataFrame with DatetimeIndex and columns from the common stock id list. This dummy alpha is equivalent to::

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{class} \PYG{n+nc}{MyAlpha2}\PYG{p}{(}\PYG{n}{BacktestingAlpha}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{def} \PYG{n+nf}{generate}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{date}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{alphas}\PYG{p}{[}\PYG{n}{date}\PYG{p}{]} \PYG{o}{=} \PYG{n}{quote}\PYG{o}{.}\PYG{n}{fetch\PYGZus{}daily}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{close}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{date}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{alpha2} \PYG{o}{=} \PYG{n}{MyAlpha}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{alpha2}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{n}{startdate}\PYG{o}{=}\PYG{l+m+mi}{20140101}\PYG{p}{,} \PYG{n}{enddate}\PYG{o}{=}\PYG{l+m+mi}{20140131}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{frames\PYGZus{}equal}\PYG{p}{(}\PYG{n}{alpha}\PYG{o}{.}\PYG{n}{get\PYGZus{}alphas}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{alpha2}\PYG{o}{.}\PYG{n}{get\PYGZus{}alphas}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{True}
\end{Verbatim}

A complete Python file for this dummy alpha::

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{orca.mongo} \PYG{k+kn}{import} \PYG{n}{QuoteFetcher}
\PYG{k+kn}{from} \PYG{n+nn}{orca.alpha} \PYG{k+kn}{import} \PYG{n}{BacktestingAlpha}

\PYG{n}{quote} \PYG{o}{=} \PYG{n}{QuoteFetcher}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{close} \PYG{o}{=} \PYG{n}{quote}\PYG{o}{.}\PYG{n}{fetch}\PYG{p}{(}\PYG{l+m+mi}{20140101}\PYG{p}{,} \PYG{l+m+mi}{20140130}\PYG{p}{)}

\PYG{k}{class} \PYG{n+nc}{MyAlpha}\PYG{p}{:}
    \PYG{k}{def} \PYG{n+nf}{generate}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{date}\PYG{p}{)}\PYG{p}{:}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{alphas}\PYG{p}{[}\PYG{n}{date}\PYG{p}{]} \PYG{o}{=} \PYG{n}{close}\PYG{o}{.}\PYG{n}{ix}\PYG{p}{[}\PYG{n}{date}\PYG{p}{]}

\PYG{k}{if} \PYG{n}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{:}

    \PYG{n}{alpha} \PYG{o}{=} \PYG{n}{MyAlpha}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{alpha}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{l+m+mi}{20140101}\PYG{p}{,} \PYG{l+m+mi}{20140130}\PYG{p}{)}
    \PYG{n}{alpha}\PYG{o}{.}\PYG{n}{get\PYGZus{}alphas}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{to\PYGZus{}csv}\PYG{p}{(}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{alpha.csv}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\end{Verbatim}

Save this file as \emph{dummy.py} and then run::

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZdl{} python dummy.py
\end{Verbatim}

The generated alpha is dumped in file \emph{alpha.csv}.


\section{Choose universes}
\label{tutorial:choose-universes}
Before jumping to performance analysis after the method \code{run} is called, it is important to associate it with a universe to make the analysis results more robust.

Example::

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{orca.universe.common} \PYG{k+kn}{import} \PYG{n}{create\PYGZus{}backtesting\PYGZus{}topliquid\PYGZus{}filter}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{univ} \PYG{o}{=} \PYG{n}{create\PYGZus{}backtesting\PYGZus{}topliquid\PYGZus{}filter}\PYG{p}{(}\PYG{l+m+mi}{70}\PYG{p}{,} \PYG{l+m+mi}{70}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{univ} \PYG{o}{=} \PYG{n}{univ}\PYG{o}{.}\PYG{n}{filter}\PYG{p}{(}\PYG{l+m+mi}{20140101}\PYG{p}{,} \PYG{l+m+mi}{20140130}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{orca.universe.common} \PYG{k+kn}{import} \PYG{n}{Liq70}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{univ2} \PYG{o}{=} \PYG{n}{Liq70}\PYG{o}{.}\PYG{n}{filter}\PYG{p}{(}\PYG{l+m+mi}{20140101}\PYG{p}{,} \PYG{l+m+mi}{20140130}\PYG{p}{)}
\end{Verbatim}

Unless the attributes \code{datetime\_index} or \code{reindex} overridden in method \code{filter} or set to False during initialization, the returned DataFrame is \textbf{always} properly formatted. Now use this universe to filter out alphas::

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{orca.operation.api} \PYG{k+kn}{import} \PYG{n}{intersect}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{alphadf} \PYG{o}{=} \PYG{n}{intersect}\PYG{p}{(}\PYG{n}{alpha}\PYG{o}{.}\PYG{n}{get\PYGZus{}alphas}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{univ}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{alphadf2} \PYG{o}{=} \PYG{n}{intersect}\PYG{p}{(}\PYG{n}{alpha}\PYG{o}{.}\PYG{n}{get\PYGZus{}alphas}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{univ2}\PYG{p}{)}
\end{Verbatim}


\section{Performance analysis}
\label{tutorial:performance-analysis}
To analyse an alpha's performance(on certain universe), Orca introduces a two-step process.

Performance
\begin{quote}

The alpha(more exactly, the DataFrame returned by method \code{get\_alphas}) is passed into a Performance class. To further analyse this alpha from different perspectives, the Performance instance provides different methods to return special Analyser instances to calculate performance metrics.
\end{quote}

Analyser
\begin{quote}

All performance metrics attached to a single alpha is actually performed in this class. It accepts a DataFrame and provides metric-calculation methods.
\end{quote}

This is better illustrated with an example::

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{orca.performance} \PYG{k+kn}{import} \PYG{n}{Performance}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{perf} \PYG{o}{=} \PYG{n}{Performance}\PYG{p}{(}\PYG{n}{alphadf}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{longshort} \PYG{o}{=} \PYG{n}{Performance}\PYG{o}{.}\PYG{n}{get\PYGZus{}longshort}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{long} \PYG{o}{=} \PYG{n}{Performance}\PYG{o}{.}\PYG{n}{get\PYGZus{}qtop}\PYG{p}{(}\PYG{l+m+mf}{0.3}\PYG{p}{,} \PYG{n}{index}\PYG{o}{=}\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{HS300}\PYG{l+s}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{qtail} \PYG{o}{=} \PYG{n}{Performance}\PYG{o}{.}\PYG{n}{get\PYGZus{}qtail}\PYG{p}{(}\PYG{l+m+mf}{0.3}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{quantiles} \PYG{o}{=} \PYG{n}{Performance}\PYG{o}{.}\PYG{n}{get\PYGZus{}quantiles}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{longshort}\PYG{o}{.}\PYG{n}{get\PYGZus{}ir}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{[...]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{qtail}\PYG{o}{.}\PYG{n}{get\PYGZus{}returns}\PYG{p}{(}\PYG{n}{cost}\PYG{o}{=}\PYG{l+m+mf}{0.001}\PYG{p}{)}
\PYG{g+go}{[...]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{long}\PYG{o}{.}\PYG{n}{get\PYGZus{}returns}\PYG{p}{(}\PYG{n}{cost}\PYG{o}{=}\PYG{l+m+mf}{0.001}\PYG{p}{,} \PYG{n}{index}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{g+go}{[...]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{i}\PYG{p}{,} \PYG{n}{q} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{quantiles}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{k}{print} \PYG{n}{i}\PYG{p}{,} \PYG{n}{q}\PYG{o}{.}\PYG{n}{get\PYGZus{}returns}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{[...]}
\end{Verbatim}

If one forgets to filter out alpha before plugging it into Performance class, this class also provides a method to make up for this::

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{perf} \PYG{o}{=} \PYG{n}{Performance}\PYG{p}{(}\PYG{n}{alpha}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{perf1} \PYG{o}{=} \PYG{n}{perf}\PYG{o}{.}\PYG{n}{get\PYGZus{}universe}\PYG{p}{(}\PYG{n}{univ}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{perf2} \PYG{o}{=} \PYG{n}{perf}\PYG{o}{.}\PYG{n}{get\PYGZus{}universe}\PYG{p}{(}\PYG{n}{univ2}\PYG{p}{)}
\end{Verbatim}

The \textbf{second} way is actually preferred. Another convenient method is that Performance can restrict an alpha on HS300, CS500 and other(the rest) to see its performance on the roughly so-called `big', `medium' and `small' universes::

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{big}\PYG{p}{,} \PYG{n}{mid}\PYG{p}{,} \PYG{n}{sml} \PYG{o}{=} \PYG{n}{perf}\PYG{o}{.}\PYG{n}{get\PYGZus{}bms}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{big}\PYG{o}{.}\PYG{n}{get\PYGZus{}original}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{get\PYGZus{}ir}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}


\section{Parallel}
\label{tutorial:parallel}

\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\emph{genindex}

\item {} 
\emph{modindex}

\item {} 
\emph{search}

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}
